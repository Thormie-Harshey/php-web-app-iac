stages:
  - create-backend-resources
  - init
  - validate
  - plan
  - apply
  - destroy

# Main Terraform image for all Terraform-specific jobs
image:
  name: hashicorp/terraform:1.10
  entrypoint: [""]

# Template for all Terraform-related jobs.
# This template will install the AWS CLI and assume the OIDC role.
.terraform_setup:
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://gitlab.com
  before_script:
    - apk --no-cache add curl python3 py3-pip
    - pip3 install --no-cache-dir awscli --break-system-packages
    - >
      export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s"
      $(aws sts assume-role-with-web-identity
      --role-arn ${ROLE_ARN}
      --role-session-name "GitLabRunner-${CI_PROJECT_ID}-${CI_PIPELINE_ID}"
      --web-identity-token ${GITLAB_OIDC_TOKEN}
      --duration-seconds 3600
      --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
      --output text))
    - aws configure set region us-east-1

# This job creates the S3 bucket and DynamoDB table for state locking.
# It now correctly stands alone with its own image and setup script.
create-backend-resources:
  stage: create-backend-resources
  image:
    name: alpine/git
    entrypoint: ["/bin/sh", "-c"] # Override the entrypoint to use the shell
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://gitlab.com
  before_script:
    - apk add --no-cache python3 py3-pip
    - pip3 install --no-cache-dir awscli --break-system-packages
    - >
      export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s"
      $(aws sts assume-role-with-web-identity
      --role-arn ${ROLE_ARN}
      --role-session-name "GitLabRunner-${CI_PROJECT_ID}-${CI_PIPELINE_ID}"
      --web-identity-token ${GITLAB_OIDC_TOKEN}
      --duration-seconds 3600
      --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
      --output text))
    - aws configure set region us-east-1
  script:
    - echo "Checking if S3 bucket ${TF_STATE_BUCKET} exists..."
    - >
      if aws s3api head-bucket --bucket ${TF_STATE_BUCKET} 2>/dev/null; then
        echo "S3 bucket already exists, skipping creation."
      else
        echo "S3 bucket does not exist, creating it..."
        aws s3api create-bucket --bucket ${TF_STATE_BUCKET}
        echo "Bucket created. Enabling versioning..."
        aws s3api put-bucket-versioning --bucket ${TF_STATE_BUCKET} --versioning-configuration Status=Enabled
      fi
    - echo "Checking if DynamoDB table ${TF_STATE_TABLE} exists..."
    - >
      if aws dynamodb describe-table --table-name ${TF_STATE_TABLE} 2>/dev/null; then
        echo "DynamoDB table already exists, skipping creation."
      else
        echo "DynamoDB table does not exist, creating it..."
        aws dynamodb create-table \
          --table-name ${TF_STATE_TABLE} \
          --attribute-definitions AttributeName=LockID,AttributeType=S \
          --key-schema AttributeName=LockID,KeyType=HASH \
          --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5
      fi
  when: manual
  allow_failure: false
  
init:
  stage: init
  extends: .terraform_setup
  script:
    - echo "Initializing Terraform with backend configuration..."
        # The -reconfigure flag is useful to apply new backend settings
    - terraform init -reconfigure -backend-config="bucket=${TF_STATE_BUCKET}" -backend-config="dynamodb_table=${TF_STATE_TABLE}" -backend-config="region=us-east-1"
    # - terraform init -backend-config="bucket=${TF_STATE_BUCKET}" -backend-config="dynamodb_table=${TF_STATE_TABLE}"
  artifacts:
    paths:
      - .terraform/
      - .terraform.lock.hcl
  dependencies:
    - create-backend-resources

validate:
  stage: validate
  extends: .terraform_setup
  script:
    - terraform init -reconfigure -backend-config="bucket=${TF_STATE_BUCKET}" -backend-config="dynamodb_table=${TF_STATE_TABLE}"
    - terraform fmt -check -recursive
    - terraform validate
  dependencies:
    - init

plan:
  stage: plan
  extends: .terraform_setup
  script:
    - terraform init -reconfigure -backend-config="bucket=${TF_STATE_BUCKET}" -backend-config="dynamodb_table=${TF_STATE_TABLE}"
    - terraform plan -out="planfile"
    - terraform show -no-color planfile > planfile.txt
  artifacts:
    paths:
      - planfile
      - .terraform.lock.hcl
    reports:
      terraform: planfile
  dependencies:
    - validate

apply:
  stage: apply
  extends: .terraform_setup
  script:
    - terraform init -reconfigure -backend-config="bucket=${TF_STATE_BUCKET}" -backend-config="dynamodb_table=${TF_STATE_TABLE}"
    - terraform apply -input=false "planfile"
    - terraform output > output.txt
  artifacts:
    paths:
      - output.txt
    reports:
      terraform: output.txt
  when: manual
  dependencies:
    - plan

destroy:
  stage: destroy
  extends: .terraform_setup
  script:
    - terraform init -reconfigure -backend-config="bucket=${TF_STATE_BUCKET}" -backend-config="dynamodb_table=${TF_STATE_TABLE}"
    - terraform destroy --auto-approve
  when: manual
  dependencies:
    - plan